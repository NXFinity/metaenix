"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1671],{4929:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"events/using","title":"Using Events","description":"Learn how to handle and process events in your application.","source":"@site/docs/events/using.md","sourceDirName":"events","slug":"/events/using","permalink":"/enix_backend/docs/events/using","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/events/using.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Subscribing to Events","permalink":"/enix_backend/docs/events/subscribing"},"next":{"title":"Event Payloads","permalink":"/enix_backend/docs/events/payloads"}}');var s=r(4848),a=r(8453);const o={sidebar_position:3},l="Using Events",i={},d=[{value:"Event Handling Patterns",id:"event-handling-patterns",level:2},{value:"Basic Event Listener",id:"basic-event-listener",level:3},{value:"Event Handler Class",id:"event-handler-class",level:3},{value:"Event Router Pattern",id:"event-router-pattern",level:3},{value:"Processing Events",id:"processing-events",level:2},{value:"Validate Event Data",id:"validate-event-data",level:3},{value:"Async Event Processing",id:"async-event-processing",level:3},{value:"Event Queue Pattern",id:"event-queue-pattern",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Retry Logic",id:"retry-logic",level:3},{value:"Dead Letter Queue",id:"dead-letter-queue",level:3},{value:"Event Filtering",id:"event-filtering",level:2},{value:"Event Transformation",id:"event-transformation",level:2},{value:"Testing Event Handlers",id:"testing-event-handlers",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"using-events",children:"Using Events"})}),"\n",(0,s.jsx)(n.p,{children:"Learn how to handle and process events in your application."}),"\n",(0,s.jsx)(n.h2,{id:"event-handling-patterns",children:"Event Handling Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"basic-event-listener",children:"Basic Event Listener"}),"\n",(0,s.jsx)(n.p,{children:"The simplest way to handle events is to listen for them:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"socket.on('new_follower', (data) => {\r\n  console.log('New follower:', data);\r\n  // Process the event\r\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"event-handler-class",children:"Event Handler Class"}),"\n",(0,s.jsx)(n.p,{children:"Create a dedicated class to handle events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class EventHandler {\r\n  constructor(socket) {\r\n    this.socket = socket;\r\n    this.setupListeners();\r\n  }\r\n\r\n  setupListeners() {\r\n    this.socket.on('new_follower', (data) => this.handleNewFollower(data));\r\n    this.socket.on('unfollow', (data) => this.handleUnfollow(data));\r\n  }\r\n\r\n  handleNewFollower(data) {\r\n    // Fetch additional user data if needed\r\n    this.fetchUserData(data.followerId)\r\n      .then(user => {\r\n        console.log('New follower:', user);\r\n        // Update your database, send notifications, etc.\r\n      })\r\n      .catch(error => {\r\n        console.error('Error handling new follower:', error);\r\n      });\r\n  }\r\n\r\n  handleUnfollow(data) {\r\n    console.log('User unfollowed:', data.followerId);\r\n    // Update your database, remove from lists, etc.\r\n  }\r\n\r\n  async fetchUserData(userId) {\r\n    // Call Meta EN|IX API to get user details\r\n    const response = await fetch(`https://api.metaenix.com/v1/users/${userId}`, {\r\n      headers: {\r\n        'Authorization': `Bearer ${accessToken}`\r\n      }\r\n    });\r\n    return response.json();\r\n  }\r\n}\r\n\r\n// Usage\r\nconst handler = new EventHandler(socket);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"event-router-pattern",children:"Event Router Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Route events to specific handlers based on event type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class EventRouter {\r\n  constructor() {\r\n    this.handlers = new Map();\r\n  }\r\n\r\n  register(eventType, handler) {\r\n    if (!this.handlers.has(eventType)) {\r\n      this.handlers.set(eventType, []);\r\n    }\r\n    this.handlers.get(eventType).push(handler);\r\n  }\r\n\r\n  async route(eventType, data) {\r\n    const handlers = this.handlers.get(eventType) || [];\r\n    await Promise.all(\r\n      handlers.map(handler => handler(data))\r\n    );\r\n  }\r\n}\r\n\r\n// Usage\r\nconst router = new EventRouter();\r\n\r\nrouter.register('new_follower', async (data) => {\r\n  console.log('Handling new follower:', data);\r\n  // Your logic here\r\n});\r\n\r\nrouter.register('new_follower', async (data) => {\r\n  // Another handler for the same event\r\n  await sendNotification(data);\r\n});\r\n\r\nsocket.on('new_follower', (data) => {\r\n  router.route('new_follower', data);\r\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"processing-events",children:"Processing Events"}),"\n",(0,s.jsx)(n.h3,{id:"validate-event-data",children:"Validate Event Data"}),"\n",(0,s.jsx)(n.p,{children:"Always validate event payloads:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function validateNewFollowerEvent(data) {\r\n  if (!data.followerId || typeof data.followerId !== 'string') {\r\n    throw new Error('Invalid followerId');\r\n  }\r\n  if (!data.timestamp || !isValidISO8601(data.timestamp)) {\r\n    throw new Error('Invalid timestamp');\r\n  }\r\n  return true;\r\n}\r\n\r\nsocket.on('new_follower', (data) => {\r\n  try {\r\n    validateNewFollowerEvent(data);\r\n    // Process valid event\r\n    handleNewFollower(data);\r\n  } catch (error) {\r\n    console.error('Invalid event data:', error);\r\n  }\r\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"async-event-processing",children:"Async Event Processing"}),"\n",(0,s.jsx)(n.p,{children:"Handle async operations properly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"socket.on('new_follower', async (data) => {\r\n  try {\r\n    // Fetch additional data\r\n    const follower = await fetchUser(data.followerId);\r\n    \r\n    // Update database\r\n    await updateDatabase({\r\n      event: 'new_follower',\r\n      followerId: data.followerId,\r\n      follower: follower,\r\n      timestamp: data.timestamp\r\n    });\r\n    \r\n    // Send notification\r\n    await sendNotification({\r\n      type: 'new_follower',\r\n      user: follower\r\n    });\r\n    \r\n    console.log('Processed new follower event');\r\n  } catch (error) {\r\n    console.error('Error processing event:', error);\r\n    // Implement retry logic or error reporting\r\n  }\r\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"event-queue-pattern",children:"Event Queue Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Queue events for processing to handle high volumes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class EventQueue {\r\n  constructor() {\r\n    this.queue = [];\r\n    this.processing = false;\r\n  }\r\n\r\n  enqueue(event) {\r\n    this.queue.push({\r\n      ...event,\r\n      queuedAt: new Date().toISOString()\r\n    });\r\n    this.process();\r\n  }\r\n\r\n  async process() {\r\n    if (this.processing || this.queue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    this.processing = true;\r\n\r\n    while (this.queue.length > 0) {\r\n      const event = this.queue.shift();\r\n      try {\r\n        await this.handleEvent(event);\r\n      } catch (error) {\r\n        console.error('Error processing event:', error);\r\n        // Re-queue or send to dead letter queue\r\n      }\r\n    }\r\n\r\n    this.processing = false;\r\n  }\r\n\r\n  async handleEvent(event) {\r\n    // Your event processing logic\r\n    console.log('Processing event:', event);\r\n  }\r\n}\r\n\r\nconst eventQueue = new EventQueue();\r\n\r\nsocket.on('new_follower', (data) => {\r\n  eventQueue.enqueue({\r\n    type: 'new_follower',\r\n    data: data\r\n  });\r\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"retry-logic",children:"Retry Logic"}),"\n",(0,s.jsx)(n.p,{children:"Implement retry logic for failed event processing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function processEventWithRetry(event, maxRetries = 3) {\r\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      await processEvent(event);\r\n      return; // Success\r\n    } catch (error) {\r\n      if (attempt === maxRetries) {\r\n        throw error; // Final attempt failed\r\n      }\r\n      // Exponential backoff\r\n      await sleep(Math.pow(2, attempt) * 1000);\r\n    }\r\n  }\r\n}\r\n\r\nsocket.on('new_follower', async (data) => {\r\n  try {\r\n    await processEventWithRetry(data);\r\n  } catch (error) {\r\n    console.error('Failed to process event after retries:', error);\r\n    // Send to dead letter queue or alert monitoring\r\n  }\r\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dead-letter-queue",children:"Dead Letter Queue"}),"\n",(0,s.jsx)(n.p,{children:"Store failed events for later processing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class DeadLetterQueue {\r\n  async store(event, error) {\r\n    // Store in database or message queue\r\n    await db.deadLetterEvents.insert({\r\n      event: event,\r\n      error: error.message,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n}\r\n\r\nconst dlq = new DeadLetterQueue();\r\n\r\nsocket.on('new_follower', async (data) => {\r\n  try {\r\n    await processEvent(data);\r\n  } catch (error) {\r\n    console.error('Event processing failed:', error);\r\n    await dlq.store(data, error);\r\n  }\r\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-filtering",children:"Event Filtering"}),"\n",(0,s.jsx)(n.p,{children:"Filter events based on your application's needs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class EventFilter {\r\n  constructor() {\r\n    this.filters = [];\r\n  }\r\n\r\n  addFilter(filterFn) {\r\n    this.filters.push(filterFn);\r\n  }\r\n\r\n  shouldProcess(event) {\r\n    return this.filters.every(filter => filter(event));\r\n  }\r\n}\r\n\r\nconst filter = new EventFilter();\r\n\r\n// Only process events for specific users\r\nfilter.addFilter((event) => {\r\n  return event.followerId !== 'blocked-user-id';\r\n});\r\n\r\n// Only process events from the last hour\r\nfilter.addFilter((event) => {\r\n  const eventTime = new Date(event.timestamp);\r\n  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\r\n  return eventTime > oneHourAgo;\r\n});\r\n\r\nsocket.on('new_follower', (data) => {\r\n  if (filter.shouldProcess(data)) {\r\n    processEvent(data);\r\n  } else {\r\n    console.log('Event filtered out:', data);\r\n  }\r\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-transformation",children:"Event Transformation"}),"\n",(0,s.jsx)(n.p,{children:"Transform events to match your application's data model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function transformNewFollowerEvent(event) {\r\n  return {\r\n    id: generateId(),\r\n    type: 'FOLLOWER_ADDED',\r\n    userId: event.followerId,\r\n    timestamp: new Date(event.timestamp),\r\n    source: 'metaenix'\r\n  };\r\n}\r\n\r\nsocket.on('new_follower', (data) => {\r\n  const transformed = transformNewFollowerEvent(data);\r\n  // Process transformed event\r\n  processEvent(transformed);\r\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing-event-handlers",children:"Testing Event Handlers"}),"\n",(0,s.jsx)(n.p,{children:"Test your event handlers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Mock socket for testing\r\nclass MockSocket {\r\n  constructor() {\r\n    this.listeners = new Map();\r\n  }\r\n\r\n  on(event, handler) {\r\n    if (!this.listeners.has(event)) {\r\n      this.listeners.set(event, []);\r\n    }\r\n    this.listeners.get(event).push(handler);\r\n  }\r\n\r\n  emit(event, data) {\r\n    const handlers = this.listeners.get(event) || [];\r\n    handlers.forEach(handler => handler(data));\r\n  }\r\n}\r\n\r\n// Test\r\nconst mockSocket = new MockSocket();\r\nconst handler = new EventHandler(mockSocket);\r\n\r\nmockSocket.emit('new_follower', {\r\n  followerId: 'test-user-id',\r\n  timestamp: new Date().toISOString()\r\n});\r\n\r\n// Assert handler was called correctly\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Idempotency"})," - Make event handlers idempotent to handle duplicate events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"})," - Always implement comprehensive error handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Logging"})," - Log all events for debugging and auditing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitoring"})," - Monitor event processing performance and errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rate Limiting"})," - Respect rate limits and implement backpressure"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"})," - Always validate event payloads"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Async Processing"})," - Use queues for heavy processing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing"})," - Write tests for your event handlers"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./payloads",children:"Event Payloads"})})," - Reference for all event types and their payloads"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var t=r(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);